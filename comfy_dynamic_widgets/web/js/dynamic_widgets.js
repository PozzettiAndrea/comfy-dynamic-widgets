/**
 * Dynamic Widget & Input Slot Visibility for ComfyUI
 *
 * Shows/hides widgets and input slots based on selector widget values
 * or upstream connection state. Mappings are loaded from mappings.json
 * (generated by write_mappings).
 *
 * Selector-based (local widget value):
 *   "voxel_size": ("FLOAT", {
 *       "default": 0.1,
 *       "visible_when": {"backend": ["blender_voxel"]},
 *   })
 *
 * Connection-based (upstream node widget value):
 *   "camera_params": ("CAMERA_PARAMS", {
 *       "visible_when_connected": {
 *           "input": "da3_model",
 *           "source_widget": "model",
 *           "contains": ["da3_small", "nested"],
 *       },
 *   })
 */
import { app } from "../../../scripts/app.js";

console.log("[DynamicWidgets] Loading extension...");

// Will be populated from JSON
let MAPPINGS = null;

/**
 * Fetch mappings from generated JSON (relative to this script's location)
 */
async function loadMappings() {
    // Get the directory this script is loaded from
    const scriptUrl = new URL(import.meta.url);
    const baseDir = scriptUrl.pathname.substring(0, scriptUrl.pathname.lastIndexOf('/'));

    // Load mappings.json from same directory
    try {
        const response = await fetch(baseDir + "/mappings.json");
        if (response.ok) {
            const data = await response.json();
            MAPPINGS = data;
            const nodeCount = Object.keys(data.nodes || {}).length;
            console.log(`[DynamicWidgets] Loaded mappings for ${nodeCount} nodes`);
            return true;
        }
    } catch (e) {
        console.warn("[DynamicWidgets] Could not load mappings.json:", e);
    }
    return false;
}

// Load mappings on startup
loadMappings();

/**
 * Get the node configuration from mappings
 */
function getNodeConfig(nodeClass) {
    if (!MAPPINGS || !MAPPINGS.nodes) return null;
    return MAPPINGS.nodes[nodeClass] || null;
}

/**
 * Hide an input slot by splicing it out of node.inputs.
 * @returns {boolean} true if visibility changed
 */
function hideInputSlot(node, slotName) {
    if (!node.inputs) return false;

    const input = node.inputs.find(i => i.name === slotName);
    if (!input) return false;

    // Use snapshotted original index if available, else current position
    input._dw_originalIndex = (node._dw_originalInputOrder && node._dw_originalInputOrder[slotName] != null)
        ? node._dw_originalInputOrder[slotName]
        : node.inputs.indexOf(input);
    input._dw_hidden = true;

    node.inputs.splice(node.inputs.indexOf(input), 1);

    if (!node._dw_hiddenInputs) node._dw_hiddenInputs = {};
    node._dw_hiddenInputs[slotName] = input;

    return true;
}

/**
 * Show a previously hidden input slot by splicing it back into node.inputs.
 * @returns {boolean} true if visibility changed
 */
function showInputSlot(node, slotName) {
    if (!node._dw_hiddenInputs || !node._dw_hiddenInputs[slotName]) return false;

    const input = node._dw_hiddenInputs[slotName];
    if (!input._dw_hidden) return false;

    if (!node.inputs) node.inputs = [];

    // Compute correct insertion index by counting visible slots
    // with lower original indices
    const myOrigIdx = input._dw_originalIndex != null ? input._dw_originalIndex : node.inputs.length;
    let insertIndex = 0;
    for (const inp of node.inputs) {
        const origIdx = (node._dw_originalInputOrder && node._dw_originalInputOrder[inp.name] != null)
            ? node._dw_originalInputOrder[inp.name]
            : Infinity;
        if (origIdx < myOrigIdx) {
            insertIndex++;
        }
    }

    if (node.inputs.indexOf(input) === -1) {
        node.inputs.splice(insertIndex, 0, input);
    }

    input._dw_hidden = false;
    delete node._dw_hiddenInputs[slotName];

    return true;
}

/**
 * Check if a name corresponds to an input slot (visible or hidden).
 */
function isInputSlot(node, name) {
    if (node.inputs && node.inputs.some(i => i.name === name)) return true;
    if (node._dw_hiddenInputs && node._dw_hiddenInputs[name]) return true;
    return false;
}

/**
 * Update widget and input slot visibility based on selector value
 */
function updateWidgetVisibility(node, selectorName, selectedValue) {
    const nodeConfig = getNodeConfig(node.comfyClass);
    if (!nodeConfig || !nodeConfig.selectors) return;

    const selectorConfig = nodeConfig.selectors[selectorName];
    if (!selectorConfig) return;

    // Get names that should be visible for this selector value
    const visibleNames = selectorConfig[selectedValue] || [];

    // Get all names controlled by this selector
    const allControlledNames = new Set();
    for (const names of Object.values(selectorConfig)) {
        for (const n of names) {
            allControlledNames.add(n);
        }
    }

    console.log(`[DynamicWidgets] ${node.comfyClass}: ${selectorName}="${selectedValue}", visible=[${visibleNames.join(', ')}]`);

    let visibilityChanged = false;

    for (const name of allControlledNames) {
        const shouldShow = visibleNames.includes(name);

        // Try as widget first
        const widget = (node.widgets || []).find(w => w.name === name);
        if (widget) {
            const wasHidden = widget.hidden;
            widget.hidden = !shouldShow;
            if (wasHidden !== widget.hidden) {
                visibilityChanged = true;
                console.log(`[DynamicWidgets] Widget "${name}": hidden=${widget.hidden}`);
            }
            continue;
        }

        // Try as input slot
        if (isInputSlot(node, name)) {
            let changed;
            if (shouldShow) {
                changed = showInputSlot(node, name);
                if (changed) console.log(`[DynamicWidgets] Input slot "${name}": shown`);
            } else {
                changed = hideInputSlot(node, name);
                if (changed) console.log(`[DynamicWidgets] Input slot "${name}": hidden`);
            }
            if (changed) visibilityChanged = true;
        }
    }

    if (visibilityChanged) {
        node.setSize(node.computeSize());
        app.graph.setDirtyCanvas(true, true);
    }
}

/**
 * Get a widget value from the node connected to a specific input slot.
 * @returns {string|null} The widget value, or null if not connected/found
 */
function getConnectedWidgetValue(node, inputName, widgetName) {
    const input = node.inputs?.find(i => i.name === inputName);
    if (!input || !input.link) return null;

    const link = app.graph.links[input.link];
    if (!link) return null;

    const sourceNode = app.graph.getNodeById(link.origin_id);
    if (!sourceNode) return null;

    const widget = sourceNode.widgets?.find(w => w.name === widgetName);
    if (!widget) return null;

    return widget.value;
}

/**
 * Set up connection-based visibility monitoring for an input slot.
 * Shows/hides items based on the upstream node's widget value.
 */
function setupConnectionMonitor(node, inputName, connectionConfig) {
    const { source_widget, contains } = connectionConfig;
    const controlledItems = Object.keys(contains || {});
    if (controlledItems.length === 0) return;

    let lastSourceValue = undefined;

    const updateVisibility = () => {
        const sourceValue = getConnectedWidgetValue(node, inputName, source_widget);

        // Skip if value hasn't changed
        if (sourceValue === lastSourceValue) return;
        lastSourceValue = sourceValue;

        let visibilityChanged = false;

        for (const itemName of controlledItems) {
            const patterns = contains[itemName] || [];

            // Determine if item should be shown
            let shouldShow;
            if (sourceValue == null) {
                // Nothing connected â€” show by default
                shouldShow = true;
            } else {
                // Check if source value contains any pattern (case-insensitive)
                const lowerValue = String(sourceValue).toLowerCase();
                shouldShow = patterns.some(p => lowerValue.includes(p.toLowerCase()));
            }

            // Try as widget first
            const widget = (node.widgets || []).find(w => w.name === itemName);
            if (widget) {
                const wasHidden = widget.hidden;
                widget.hidden = !shouldShow;
                if (wasHidden !== widget.hidden) {
                    visibilityChanged = true;
                    console.log(`[DynamicWidgets] Widget "${itemName}": hidden=${widget.hidden} (connection)`);
                }
                continue;
            }

            // Try as input slot
            if (isInputSlot(node, itemName)) {
                let changed;
                if (shouldShow) {
                    changed = showInputSlot(node, itemName);
                    if (changed) console.log(`[DynamicWidgets] Input slot "${itemName}": shown (connection)`);
                } else {
                    changed = hideInputSlot(node, itemName);
                    if (changed) console.log(`[DynamicWidgets] Input slot "${itemName}": hidden (connection)`);
                }
                if (changed) visibilityChanged = true;
            }
        }

        if (visibilityChanged) {
            node.setSize(node.computeSize());
            app.graph.setDirtyCanvas(true, true);
        }
    };

    // Monitor connection changes
    const origOnConnectionsChange = node.onConnectionsChange;
    node.onConnectionsChange = function(type, index, connected, link_info) {
        if (origOnConnectionsChange) origOnConnectionsChange.apply(this, arguments);
        // type 1 = input connection
        if (type === 1) {
            setTimeout(() => updateVisibility(), 100);
        }
    };

    // Initial check
    setTimeout(() => updateVisibility(), 200);

    // Poll for upstream widget value changes
    const pollInterval = setInterval(() => {
        if (!node.graph) {
            clearInterval(pollInterval);
            return;
        }
        updateVisibility();
    }, 2000);

    // Cleanup on node removal
    const origOnRemoved = node.onRemoved;
    node.onRemoved = function() {
        clearInterval(pollInterval);
        if (origOnRemoved) origOnRemoved.apply(this, arguments);
    };
}

/**
 * Set up visibility control for a selector widget
 */
function setupSelectorWidget(node, selectorName) {
    const selectorWidget = node.widgets?.find(w => w.name === selectorName);
    if (!selectorWidget) {
        console.log(`[DynamicWidgets] Selector widget "${selectorName}" not found on ${node.comfyClass}`);
        return;
    }

    // Store original callback
    const originalCallback = selectorWidget.callback;

    // Override callback to update visibility on change
    selectorWidget.callback = function(value) {
        if (originalCallback) originalCallback.call(this, value);
        updateWidgetVisibility(node, selectorName, value);
    };

    // Initial visibility update (with delay to ensure widgets are created)
    setTimeout(() => {
        updateWidgetVisibility(node, selectorName, selectorWidget.value);
    }, 50);
}

app.registerExtension({
    name: "Comfy.DynamicWidgets",

    nodeCreated(node) {
        const nodeConfig = getNodeConfig(node.comfyClass);
        if (!nodeConfig) return;

        const hasSelectors = nodeConfig.selectors && Object.keys(nodeConfig.selectors).length > 0;
        const hasConnections = nodeConfig.connections && Object.keys(nodeConfig.connections).length > 0;
        if (!hasSelectors && !hasConnections) return;

        console.log(`[DynamicWidgets] Setting up node: ${node.comfyClass}`);

        // Initialize input slot tracking
        node._dw_hiddenInputs = {};
        node._dw_originalInputOrder = {};
        if (node.inputs) {
            for (let i = 0; i < node.inputs.length; i++) {
                node._dw_originalInputOrder[node.inputs[i].name] = i;
            }
        }

        // Set up selector-based visibility
        if (hasSelectors) {
            for (const selectorName of Object.keys(nodeConfig.selectors)) {
                setupSelectorWidget(node, selectorName);
            }
        }

        // Set up connection-based visibility
        if (hasConnections) {
            for (const [inputName, config] of Object.entries(nodeConfig.connections)) {
                setupConnectionMonitor(node, inputName, config);
            }
        }
    }
});

console.log("[DynamicWidgets] Extension registered");
